/***********************************************
这道题目我选择了另外一道题来做，都属于正则表达式匹配

问题描述
　　考虑一种简单的正则表达式：
　　只由 x ( ) | 组成的正则表达式。
　　小明想求出这个正则表达式能接受的最长字符串的长度。


　　例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。
  
 代码参考： https://blog.csdn.net/laichilizi/article/details/79388913  
 这道题目想了挺久的，说明自己对DFS的理解以及各变量的作用域还是不熟悉，需要勤思考。
 建议考试前可以再看一遍
***********************************************/

#include<bits/stdc++.h>
using namespace std;  
 
string str;  
// 在对变量设置时应该思考，这些变量无论如何迭代，都是会变化的，并且保留下来，作为全局变量应有的特性
int p,len,ans;
  
int dfs(){  
    // 这里创建的变量会随着迭代的进行发生改变
    int num = 0, res = 0;  
    while (p < len) {  
    	// 核心部分，每次遇到(就要进行迭代， 
        if (str[p] == '(') {  
            p++; 
            // 保存的是当前括号中的最大值
            num += dfs();  
        }  
        // 当遇到)说明已经拥有两个数值，分别是num和res，比较两个大小再返回这个()里面的最大值 
        else if (str[p] == ')') {  
            p++;  
            break;  
        }  
        // 当遇到|，取目前的最大值，再把num置为0去记录‘|’右边的字符串长度 
        else if (str[p] == '|') {  
            p++;  
            //当遇到|时我们就应该思考，此时就应该直接进行比较，不需要讨论是第几个|，我们只需要其中的最大值，并且每次比较完都说明到|的另一边需要记录
            res = max(num, res);  
            num = 0;  
        }
        // 遇到'x'时直接++ 
        else {  
            p++;  
            num++;
        }  
    }  
    // 取num和res的最大值，这里是遇到')'结束循环出来的，之后就可以返回这()的最大长度到上一层的(中 
    res = max(num, res);  
    return res;  
}  
int main() 
{  
    cin >> str;    
    len = str.size(),p = 0;  
    ans = dfs();  
    cout << ans << endl;  
    return 0;  
}
